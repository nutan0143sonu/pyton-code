Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] on win32
Type "copyright", "credits" or "license()" for more information.
>>> 
============== RESTART: C:/Python/Python36-32/4july_sklearn2.py ==============
(500, 2)
[[ 1.01434371  4.42438414]
 [-1.64868653  3.13519281]
 [-1.67915929  2.60231823]
 [ 1.16830954  3.81870051]
 [ 0.39538614  4.36042091]
 [ 0.96781541  4.43228689]
 [ 0.78318456  3.63676638]
 [-1.46751383  3.24246283]
 [-1.45848802  2.97832625]
 [ 1.20042658  3.94710384]
 [-1.79612429  3.31162337]
 [-1.53136132  3.16430404]
 [-1.78459573  2.64819961]
 [-1.2024912   2.72846946]
 [ 0.58149786  4.16531195]
 [ 0.94082087  4.09973387]
 [ 2.33818135  0.07576051]
 [ 1.62524086  4.70474571]
 [-1.37748829  2.91002459]
 [ 0.95778216  4.27159574]
 [ 2.15693876  1.50397673]
 [ 1.74628694  0.79268065]
 [ 2.02948829  0.95595154]
 [-1.76350479  3.24627377]
 [ 1.08919774  3.97396709]
 [-1.35770145  2.53251657]
 [ 1.78263855  0.77036837]
 [-1.24462873  3.03944349]
 [ 0.71503093  4.13013243]
 [-1.36822093  2.9917266 ]
 [-1.31090889  2.5870104 ]
 [ 1.34535728  4.66450128]
 [ 0.70242341  4.63889221]
 [ 0.17851841  4.48568318]
 [ 1.93987389  0.76451283]
 [ 1.4268866   0.93478023]
 [ 2.05056289  0.94594211]
 [ 2.38417158  0.82739892]
 [ 1.88897463  0.75647236]
 [ 1.45400281  1.01072662]
 [-1.76459001  2.75840049]
 [ 1.1041477   4.50685974]
 [ 1.69121351  4.58713117]
 [ 2.38535282  1.28707025]
 [ 2.4096811   0.70809253]
 [ 0.82686034  4.88264694]
 [ 1.94585946  0.94467482]
 [ 1.18321553  4.6943412 ]
 [-1.58642368  2.94613995]
 [-1.8801927   2.57582337]
 [ 0.82337442  4.17236504]
 [ 1.23331926  4.10847965]
 [ 0.78551626  4.50671732]
 [ 0.86080614  4.3320928 ]
 [-1.72721783  3.42245878]
 [-1.68337792  2.56247628]
 [ 1.65560403  0.30707625]
 [ 1.84907781  0.8624213 ]
 [ 1.10942905  4.40388963]
 [-0.89186671  2.43461874]
 [ 2.50926595  1.06360328]
 [-1.10650056  2.79476772]
 [ 1.85770163  0.74339347]
 [ 1.7596143   0.45611316]
 [ 2.14055142  1.42046429]
 [-2.0197936   2.79606072]
 [ 1.09598398  3.4720095 ]
 [ 1.97494746  0.55926026]
 [-1.04907279  2.84031047]
 [ 0.83961033  4.30903108]
 [-1.42105903  2.87204993]
 [ 0.70763011  4.41985808]
 [ 0.71790237  4.87680681]
 [-1.72428184  3.20854705]
 [ 2.86413474  0.87548626]
 [-1.43788406  3.16687811]
 [ 2.07011602  1.04581469]
 [ 1.90001181  0.6040147 ]
 [ 1.77986609  0.97341265]
 [ 1.65406276  4.29111018]
 [ 1.30616796  4.50036645]
 [ 0.93548517  4.64485474]
 [-1.65359846  2.94929647]
 [ 0.78784381  4.15947919]
 [-2.016631    2.89774201]
 [ 2.13940003  0.59972658]
 [-1.76784643  2.77858095]
 [-1.45868618  2.61286067]
 [-1.22335128  2.72049695]
 [-1.78267977  2.92477019]
 [ 0.73524718  4.09692239]
 [ 1.08318     4.51575928]
 [ 2.57508388  1.10301399]
 [ 0.51403097  4.32276593]
 [-1.1806488   2.96963359]
 [ 2.31801735  0.86313142]
 [-1.51497399  2.44778385]
 [-1.10355239  3.15362341]
 [-1.11560731  2.76492929]
 [ 0.6929362   4.18077242]
 [ 2.57692932  1.19598198]
 [-1.75426527  2.90285703]
 [-2.00745483  2.65172798]
 [ 0.98999763  4.24763217]
 [ 0.77106681  4.80165257]
 [ 1.45034553  0.73582727]
 [ 1.02275431  4.41723608]
 [ 2.49524114  1.15342924]
 [ 1.1837317   4.51221207]
 [ 1.97677389  0.84299022]
 [ 0.81341164  4.42860234]
 [ 0.85643537  4.41480409]
 [ 1.67136077  0.7220343 ]
 [-1.11132555  2.82695279]
 [-1.62049685  2.66579514]
 [ 1.84891624  0.53344044]
 [-1.51143153  3.17806525]
 [ 2.2254546   0.83086113]
 [ 1.91425766  0.83264422]
 [-1.34332586  2.51543324]
 [-1.63077885  2.67949137]
 [ 1.65719647  3.86747763]
 [-1.08009722  3.07427339]
 [-1.82895354  3.42235528]
 [-1.676609    2.92428763]
 [ 1.09697257  4.0983443 ]
 [-1.51772347  2.89698979]
 [ 1.13343739  4.33031395]
 [-1.12896552  2.62850033]
 [ 0.89586907  4.54452425]
 [ 2.01623544  0.92584963]
 [ 1.21216847  4.1638616 ]
 [-1.72105844  3.05955641]
 [ 1.99807147  0.77920881]
 [ 0.6196123   4.15174242]
 [ 2.25820574  0.78306097]
 [-1.78140017  2.82018142]
 [-1.80826808  3.04781465]
 [ 1.85185979  1.2870174 ]
 [ 0.94673432  4.10474384]
 [ 1.42274574  4.87255408]
 [-1.23514328  3.55804274]
 [-1.80263805  2.97570842]
 [ 2.24826186  0.42647664]
 [ 1.16383951  3.82317003]
 [ 0.70408057  4.31937095]
 [ 0.76789972  4.25889697]
 [ 2.14133887  0.20148538]
 [ 2.01595132  1.23758762]
 [ 0.92896997  4.98080438]
 [ 2.04155633  0.96381596]
 [ 0.85218438  4.07955088]
 [ 0.58431202  4.80122653]
 [ 1.24932375  4.39895279]
 [ 2.3126447   1.23999422]
 [ 0.94310788  4.60983914]
 [-1.1293998   2.97948203]
 [ 1.62130711  1.13775304]
 [-1.2459703   2.90735371]
 [ 0.96448523  3.95335928]
 [ 2.17008725  0.88739098]
 [ 1.70152014  1.28809208]
 [-1.64296527  2.76479444]
 [-1.50452809  2.59475254]
 [-1.5302477   2.92133193]
 [ 2.31595657  0.98072523]
 [ 0.77453194  4.19592138]
 [ 2.21826109  1.02937655]
 [ 0.58841301  4.38390259]
 [ 2.16080155  1.01143432]
 [-1.41755964  3.35927885]
 [-1.80859849  3.22298856]
 [ 2.3077569   0.82282609]
 [ 1.12439261  4.26895615]
 [ 1.20780724  4.55083857]
 [-1.3002853   3.17810448]
 [-1.56133661  3.01050763]
 [ 1.98798984  0.80698874]
 [ 1.91137078  1.08377115]
 [ 1.89155393  0.33228791]
 [ 2.16651502  0.9402822 ]
 [ 1.92299073  0.81355701]
 [-1.54350978  2.83870106]
 [-1.63642058  2.380484  ]
 [ 1.83655412  0.95663088]
 [ 2.02815292  1.30794283]
 [ 0.97116395  4.41753285]
 [ 2.3238456   1.31015288]
 [ 0.70993435  3.70954839]
 [-1.75661467  3.08461835]
 [-1.54447998  2.82261933]
 [ 0.68948658  4.19999279]
 [ 1.91912631  1.01864302]
 [ 2.42272869  0.91712049]
 [ 0.94530442  4.42696688]
 [-1.80674073  3.29087808]
 [ 2.03508484  0.5021449 ]
 [ 0.63202948  4.17244131]
 [-1.37473233  2.88301335]
 [ 1.91521386  0.47259183]
 [-1.44422381  3.34839708]
 [ 2.45100858  0.63293801]
 [ 1.20824597  3.94862314]
 [ 0.66269407  4.66713091]
 [-1.76673073  2.99011851]
 [ 1.37859825  0.59091161]
 [ 1.65088989  0.66919164]
 [ 1.34601538  0.90376391]
 [-2.03337302  2.88414247]
 [-1.77820743  2.74052733]
 [ 1.14924732  4.2412977 ]
 [ 1.53256066  0.50669083]
 [ 1.55090206  0.63097225]
 [-1.54414487  2.80051715]
 [-1.24778146  2.86528734]
 [ 1.18440202  4.2559153 ]
 [-1.77215194  2.49747807]
 [ 1.55315269  4.74794176]
 [-1.75553837  2.65154822]
 [-1.32573288  2.70563055]
 [ 2.11505758  0.8824826 ]
 [-1.51336381  3.6197697 ]
 [ 1.98266157  1.35314201]
 [ 1.93755082 -0.01617926]
 [ 1.53653777  4.57560072]
 [ 1.32196955  4.62767291]
 [ 0.87189643  4.35069202]
 [ 2.36394817  0.87597756]
 [-1.54930441  2.99549719]
 [ 0.76865512  4.76470044]
 [ 0.6290635   4.21009965]
 [-1.8711873   2.81044804]
 [-1.00040817  2.87798573]
 [ 2.06685669  0.40064913]
 [-1.52323442  3.38866015]
 [-1.45502919  2.80694191]
 [ 1.09507209  3.97586887]
 [ 1.949238    0.4127214 ]
 [ 1.13258954  4.13105094]
 [ 1.23560094  4.08113782]
 [ 0.62433306  4.88687368]
 [ 2.05785589  1.05576492]
 [ 1.85957944  0.74130687]
 [ 1.98848582  0.62373989]
 [ 1.26044567  4.2572843 ]
 [-1.89489051  3.20811611]
 [-1.40497937  2.85992925]
 [-1.38577407  3.01131638]
 [-1.52058541  2.9477186 ]
 [-1.59364712  2.66020629]
 [ 1.92081791  0.70286228]
 [-1.73838042  3.12187471]
 [-1.30997387  2.9252659 ]
 [ 0.78503897  4.18460578]
 [-1.2831018   3.09406008]
 [-1.81115059  2.9912153 ]
 [ 0.59512458  4.59460634]
 [ 2.1924922   0.60828006]
 [-1.68665099  3.11139884]
 [ 1.52470599  1.0043082 ]
 [ 2.19420662  0.98139239]
 [ 0.75284363  4.05585577]
 [ 0.78597345  4.19496498]
 [ 2.01569493  1.0190922 ]
 [ 1.88447391  0.97863497]
 [ 0.79707526  4.23241081]
 [-1.14738066  2.98133137]
 [ 2.549708    0.94693199]
 [-1.43440464  2.50445722]
 [ 2.26480467  0.89879493]
 [ 2.04824059  1.22142208]
 [-1.96038607  2.55471936]
 [ 2.23223147  0.78850602]
 [ 1.01885603  4.2079888 ]
 [ 0.57599254  3.89977208]
 [ 2.28526648  1.00455151]
 [ 1.32990395  4.24980988]
 [ 2.33482203  0.99965316]
 [ 1.59013872  1.02285931]
 [ 1.74985496  0.87430723]
 [ 1.4715566   0.62382861]
 [-1.97762298  2.38458217]
 [ 2.51126598  1.41354045]
 [ 0.86551553  4.23197357]
 [ 1.31426086  3.97980787]
 [ 0.9557976   4.81779014]
 [ 0.50138856  4.48690114]
 [-1.31708987  2.59951558]
 [-1.5574132   2.92366608]
 [ 1.36868151  0.97310898]
 [ 2.36559049  0.59879987]
 [-1.654303    2.66889288]
 [-1.3838345   2.96241714]
 [ 0.97942008  4.83954848]
 [ 0.75859087  3.88877814]
 [ 2.22882397  1.00256   ]
 [-1.75181112  2.92772489]
 [ 1.19499725  4.3424822 ]
 [-1.39459414  2.97152012]
 [ 1.99319642  1.16171733]
 [ 1.56304377  4.42081532]
 [ 2.19511745  0.78659093]
 [-1.24598445  2.76019008]
 [ 2.44106272  0.44556414]
 [ 0.64495508  4.31943685]
 [-1.41664054  2.97497573]
 [ 0.60863942  4.55709622]
 [ 1.96253319  0.82762366]
 [ 1.16049389  4.58044933]
 [-1.45922951  3.33462586]
 [ 1.68988597  0.80617457]
 [-1.30018193  2.75614247]
 [-1.53763443  3.63210587]
 [ 1.43610384  4.74459496]
 [ 0.54905181  4.15579136]
 [ 1.2045814   4.34028983]
 [ 2.12242059  0.99655055]
 [-1.68671485  3.24510718]
 [-1.60983387  2.84000917]
 [ 0.76038876  4.05988943]
 [ 0.96897224  4.08237805]
 [ 1.94405632  0.61397892]
 [-0.92268597  2.82585253]
 [ 1.87567134  0.56289456]
 [ 1.01948315  4.74006938]
 [ 0.46438902  4.88901995]
 [ 1.90442251  1.62139976]
 [ 2.29962347  0.91534134]
 [ 0.7805475   4.18650131]
 [-1.67851151  2.6731448 ]
 [ 2.33629026  1.32136197]
 [ 1.54121529  3.89945961]
 [ 1.77622057  0.84408693]
 [-1.26784812  2.67645614]
 [ 1.96771631  0.669216  ]
 [ 1.50234666  0.75427146]
 [ 0.62941535  4.53814676]
 [-1.22036684  2.75212006]
 [ 0.66170419  3.87778195]
 [-1.36011521  3.18562443]
 [ 1.76393615  0.99210882]
 [-1.44016786  3.04174351]
 [ 2.33411905  1.07233104]
 [ 1.11596881  3.84291422]
 [ 1.00558757  4.47867343]
 [ 1.06024746  4.27434221]
 [ 1.73887898  1.14373801]
 [ 0.77397028  4.31333649]
 [ 0.49210072  4.23996524]
 [-1.93483823  2.90546202]
 [ 1.92351066  0.95206519]
 [ 0.75440118  4.76669171]
 [-2.07418101  3.00896343]
 [-1.41905269  2.87451222]
 [-1.6353838   3.2372578 ]
 [ 1.42461544  3.68279182]
 [ 2.39384574  1.04646394]
 [ 1.82602434  0.46632622]
 [ 2.0221207   0.39945372]
 [-1.45645756  3.55752828]
 [ 0.79737587  4.28801714]
 [ 2.12790291  0.63104758]
 [-1.7272201   3.01597104]
 [ 0.48721057  4.442622  ]
 [ 0.83719129  4.44823177]
 [ 1.02322204  4.37344164]
 [-0.8229099   2.53413393]
 [ 1.33267902  4.39887011]
 [-1.46105115  3.03580114]
 [ 1.26109632  4.3300527 ]
 [-1.50893561  2.85412535]
 [-1.95347997  3.51726909]
 [ 1.4244938   4.24223985]
 [-1.68748506  2.92550382]
 [-1.59930535  2.65442516]
 [-1.10000896  3.03670824]
 [-1.42944313  3.21701766]
 [ 1.98940521  0.57245267]
 [ 1.94272339  0.5298048 ]
 [-1.55820706  2.62148168]
 [ 2.06636924  1.12803438]
 [-1.38256948  3.7456888 ]
 [-1.67573471  2.89544077]
 [-1.42789348  3.58566556]
 [-1.63656934  3.19931002]
 [ 1.176185    4.16557139]
 [ 0.93615961  4.62711047]
 [ 0.73232619  3.78590255]
 [ 2.31404632  0.10097793]
 [-1.31977531  3.15688389]
 [ 0.7322608   3.86386003]
 [ 1.54583578  1.0138478 ]
 [ 1.17795851  4.42602588]
 [ 2.29543696  0.92114171]
 [ 0.84572401  4.85856645]
 [ 2.2048746   1.21205531]
 [-1.52379922  3.13389239]
 [-1.91651003  3.30070487]
 [ 1.07019039  4.04755861]
 [-0.74857664  2.79667257]
 [ 2.12295012  1.03257729]
 [ 0.87007191  3.89130194]
 [ 1.99975142  0.65536911]
 [-1.21777253  2.30368518]
 [-1.73580201  2.83076313]
 [ 1.31809028  3.93333958]
 [ 2.37582034  0.76164792]
 [-2.301743    2.57169715]
 [ 2.10444609  0.92656007]
 [-1.1285692   2.88749782]
 [ 0.66599723  4.50826568]
 [ 0.4495029   4.43906767]
 [ 0.21037313  4.49987291]
 [ 1.93669883  0.54983751]
 [-0.7777439   2.24428577]
 [ 0.76486     4.58676554]
 [ 0.62672513  4.57403527]
 [ 1.95103233  0.72328312]
 [-1.83669694  2.78685776]
 [-1.29509556  2.41940277]
 [ 0.88300423  4.33300738]
 [-1.66229492  2.99758865]
 [ 2.46462708  0.6908289 ]
 [ 0.99622525  4.3945289 ]
 [-1.72384312  2.06751591]
 [ 0.93640591  4.21445006]
 [ 2.11026928  1.39894657]
 [ 0.63822234  4.084584  ]
 [-1.93813201  3.17757814]
 [ 0.85531699  4.67052085]
 [ 1.06574153  4.7017031 ]
 [ 1.77544525  0.51874316]
 [ 1.05862499  4.0365128 ]
 [ 1.06217319  4.48644048]
 [ 1.02949792  4.18325305]
 [ 0.74529526  4.46556208]
 [ 1.99439847  0.86469883]
 [ 1.25252773  4.39940562]
 [ 1.56547716  0.42733334]
 [-1.78386881  2.45540604]
 [ 1.91460827  0.23723127]
 [ 1.34439145  1.15687935]
 [ 0.36706474  4.92313519]
 [-1.51161773  2.37961348]
 [ 2.33800796  0.81738524]
 [-1.42773099  3.2026562 ]
 [ 2.16169483  1.08272963]
 [-1.63129257  2.5118656 ]
 [ 2.08981188  0.78391939]
 [ 1.02627213  4.49429676]
 [-1.44555296  2.6774332 ]
 [ 2.65864453  0.88428503]
 [ 2.11378843  0.3631948 ]
 [ 1.87507025  1.36333661]
 [ 1.71332678  1.13315092]
 [ 1.99018265  1.03128164]
 [ 0.82302854  3.94959767]
 [-1.38638844  3.43864596]
 [ 2.30174324  0.89925145]
 [-1.47172636  2.80223533]
 [ 0.96361864  4.21772117]
 [ 1.03875257  4.59677904]
 [ 1.76711621  0.65972845]
 [-1.39244543  3.42673673]
 [-1.96542382  2.71285033]
 [ 0.67620547  3.840356  ]
 [-1.56997787  2.80327463]
 [ 2.37872671  0.12990826]
 [ 0.88356619  3.80098619]
 [ 0.60043147  4.53703443]
 [ 2.15041571  1.05367584]
 [ 1.63347865  0.72064637]
 [-0.97202664  2.85363226]
 [ 2.03842762  0.89724815]
 [-1.70432481  3.25520802]
 [ 2.11931154  0.53509156]
 [ 1.97256636  0.68474527]
 [ 1.3833863   1.01811338]
 [ 2.1914021   0.34874154]
 [-1.23869599  3.31660112]
 [ 0.86007203  4.2130965 ]
 [ 1.81357957  0.56217008]
 [ 1.46972629  0.69969614]
 [ 0.5288928   4.43560484]
 [ 1.82047877  0.86454687]
 [-1.36819044  3.04467085]
 [-1.41714938  3.30722984]
 [ 1.2612966   4.25838016]
 [ 1.85725063  0.95040935]
 [ 1.77195697  0.9690946 ]
 [-1.64879495  2.65866876]
 [ 1.13325308  4.25232343]
 [-1.78242277  3.46469934]
 [ 0.88280432  4.32063693]
 [ 1.66744509  3.98578258]
 [ 2.23680355  1.16633046]
 [ 2.30136406  1.30564822]
 [ 2.28668931  1.20649531]
 [ 0.65504429  4.62012285]
 [ 2.19101425  0.9270325 ]]
(500,)
[0 2 2 0 0 0 0 2 2 0 2 2 2 2 0 0 1 0 2 0 1 1 1 2 0 2 1 2 0 2 2 0 0 0 1 1 1
 1 1 1 2 0 0 1 1 0 1 0 2 2 0 0 0 0 2 2 1 1 0 2 1 2 1 1 1 2 0 1 2 0 2 0 0 2
 1 2 1 1 1 0 0 0 2 0 2 1 2 2 2 2 0 0 1 0 2 1 2 2 2 0 1 2 2 0 0 1 0 1 0 1 0
 0 1 2 2 1 2 1 1 2 2 0 2 2 2 0 2 0 2 0 1 0 2 1 0 1 2 2 1 0 0 2 2 1 0 0 0 1
 1 0 1 0 0 0 1 0 2 1 2 0 1 1 2 2 2 1 0 1 0 1 2 2 1 0 0 2 2 1 1 1 1 1 2 2 1
 1 0 1 0 2 2 0 1 1 0 2 1 0 2 1 2 1 0 0 2 1 1 1 2 2 0 1 1 2 2 0 2 0 2 2 1 2
 1 1 0 0 0 1 2 0 0 2 2 1 2 2 0 1 0 0 0 1 1 1 0 2 2 2 2 2 1 2 2 0 2 2 0 1 2
 1 1 0 0 1 1 0 2 1 2 1 1 2 1 0 0 1 0 1 1 1 1 2 1 0 0 0 0 2 2 1 1 2 2 0 0 1
 2 0 2 1 0 1 2 1 0 2 0 1 0 2 1 2 2 0 0 0 1 2 2 0 0 1 2 1 0 0 1 1 0 2 1 0 1
 2 1 1 0 2 0 2 1 2 1 0 0 0 1 0 0 2 1 0 2 2 2 0 1 1 1 2 0 1 2 0 0 0 2 0 2 0
 2 2 0 2 2 2 2 1 1 2 1 2 2 2 2 0 0 0 1 2 0 1 0 1 0 1 2 2 0 2 1 0 1 2 2 0 1
 2 1 2 0 0 0 1 2 0 0 1 2 2 0 2 1 0 2 0 1 0 2 0 0 1 0 0 0 0 1 0 1 2 1 1 0 2
 1 2 1 2 1 0 2 1 1 1 1 1 0 2 1 2 0 0 1 2 2 0 2 1 0 0 1 1 2 1 2 1 1 1 1 2 0
 1 1 0 1 2 2 0 1 1 2 0 2 0 0 1 1 1 0 1]
>>> help('sklearn.datasets.samples_generator import make_blobs')
No Python documentation found for 'sklearn.datasets.samples_generator import make_blobs'.
Use help() to get the interactive help utility.
Use help(str) for help on the str class.

>>> help(sklearn.datasets.samples_generator import make_blobs)
SyntaxError: invalid syntax
>>> help(from sklearn.datasets.samples_generator import make_blobs)
SyntaxError: invalid syntax
>>> help( sklearn.datasets.samples_generator )
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    help( sklearn.datasets.samples_generator )
NameError: name 'sklearn' is not defined
>>> help( 'sklearn.datasets.samples_generator ')
Help on module sklearn.datasets.samples_generator in sklearn.datasets:

NAME
    sklearn.datasets.samples_generator - Generate samples of synthetic data sets.

FUNCTIONS
    make_biclusters(shape, n_clusters, noise=0.0, minval=10, maxval=100, shuffle=True, random_state=None)
        Generate an array with constant block diagonal structure for
        biclustering.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        shape : iterable (n_rows, n_cols)
            The shape of the result.
        
        n_clusters : integer
            The number of biclusters.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise.
        
        minval : int, optional (default=10)
            Minimum value of a bicluster.
        
        maxval : int, optional (default=100)
            Maximum value of a bicluster.
        
        shuffle : boolean, optional (default=True)
            Shuffle the samples.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape `shape`
            The generated array.
        
        rows : array of shape (n_clusters, X.shape[0],)
            The indicators for cluster membership of each row.
        
        cols : array of shape (n_clusters, X.shape[1],)
            The indicators for cluster membership of each column.
        
        References
        ----------
        
        .. [1] Dhillon, I. S. (2001, August). Co-clustering documents and
            words using bipartite spectral graph partitioning. In Proceedings
            of the seventh ACM SIGKDD international conference on Knowledge
            discovery and data mining (pp. 269-274). ACM.
        
        See also
        --------
        make_checkerboard
    
    make_blobs(n_samples=100, n_features=2, centers=3, cluster_std=1.0, center_box=(-10.0, 10.0), shuffle=True, random_state=None)
        Generate isotropic Gaussian blobs for clustering.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The total number of points equally divided among clusters.
        
        n_features : int, optional (default=2)
            The number of features for each sample.
        
        centers : int or array of shape [n_centers, n_features], optional
            (default=3)
            The number of centers to generate, or the fixed center locations.
        
        cluster_std : float or sequence of floats, optional (default=1.0)
            The standard deviation of the clusters.
        
        center_box : pair of floats (min, max), optional (default=(-10.0, 10.0))
            The bounding box for each cluster center when centers are
            generated at random.
        
        shuffle : boolean, optional (default=True)
            Shuffle the samples.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The generated samples.
        
        y : array of shape [n_samples]
            The integer labels for cluster membership of each sample.
        
        Examples
        --------
        >>> from sklearn.datasets.samples_generator import make_blobs
        >>> X, y = make_blobs(n_samples=10, centers=3, n_features=2,
        ...                   random_state=0)
        >>> print(X.shape)
        (10, 2)
        >>> y
        array([0, 0, 1, 0, 2, 2, 2, 1, 1, 0])
        
        See also
        --------
        make_classification: a more intricate variant
    
    make_checkerboard(shape, n_clusters, noise=0.0, minval=10, maxval=100, shuffle=True, random_state=None)
        Generate an array with block checkerboard structure for
        biclustering.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        shape : iterable (n_rows, n_cols)
            The shape of the result.
        
        n_clusters : integer or iterable (n_row_clusters, n_column_clusters)
            The number of row and column clusters.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise.
        
        minval : int, optional (default=10)
            Minimum value of a bicluster.
        
        maxval : int, optional (default=100)
            Maximum value of a bicluster.
        
        shuffle : boolean, optional (default=True)
            Shuffle the samples.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape `shape`
            The generated array.
        
        rows : array of shape (n_clusters, X.shape[0],)
            The indicators for cluster membership of each row.
        
        cols : array of shape (n_clusters, X.shape[1],)
            The indicators for cluster membership of each column.
        
        
        References
        ----------
        
        .. [1] Kluger, Y., Basri, R., Chang, J. T., & Gerstein, M. (2003).
            Spectral biclustering of microarray data: coclustering genes
            and conditions. Genome research, 13(4), 703-716.
        
        See also
        --------
        make_biclusters
    
    make_circles(n_samples=100, shuffle=True, noise=None, random_state=None, factor=0.8)
        Make a large circle containing a smaller circle in 2d.
        
        A simple toy dataset to visualize clustering and classification
        algorithms.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The total number of points generated.
        
        shuffle : bool, optional (default=True)
            Whether to shuffle the samples.
        
        noise : double or None (default=None)
            Standard deviation of Gaussian noise added to the data.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        factor : double < 1 (default=.8)
            Scale factor between inner and outer circle.
        
        Returns
        -------
        X : array of shape [n_samples, 2]
            The generated samples.
        
        y : array of shape [n_samples]
            The integer labels (0 or 1) for class membership of each sample.
    
    make_classification(n_samples=100, n_features=20, n_informative=2, n_redundant=2, n_repeated=0, n_classes=2, n_clusters_per_class=2, weights=None, flip_y=0.01, class_sep=1.0, hypercube=True, shift=0.0, scale=1.0, shuffle=True, random_state=None)
        Generate a random n-class classification problem.
        
        This initially creates clusters of points normally distributed (std=1)
        about vertices of an `n_informative`-dimensional hypercube with sides of
        length `2*class_sep` and assigns an equal number of clusters to each
        class. It introduces interdependence between these features and adds
        various types of further noise to the data.
        
        Prior to shuffling, `X` stacks a number of these primary "informative"
        features, "redundant" linear combinations of these, "repeated" duplicates
        of sampled features, and arbitrary noise for and remaining features.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        n_features : int, optional (default=20)
            The total number of features. These comprise `n_informative`
            informative features, `n_redundant` redundant features, `n_repeated`
            duplicated features and `n_features-n_informative-n_redundant-
            n_repeated` useless features drawn at random.
        
        n_informative : int, optional (default=2)
            The number of informative features. Each class is composed of a number
            of gaussian clusters each located around the vertices of a hypercube
            in a subspace of dimension `n_informative`. For each cluster,
            informative features are drawn independently from  N(0, 1) and then
            randomly linearly combined within each cluster in order to add
            covariance. The clusters are then placed on the vertices of the
            hypercube.
        
        n_redundant : int, optional (default=2)
            The number of redundant features. These features are generated as
            random linear combinations of the informative features.
        
        n_repeated : int, optional (default=0)
            The number of duplicated features, drawn randomly from the informative
            and the redundant features.
        
        n_classes : int, optional (default=2)
            The number of classes (or labels) of the classification problem.
        
        n_clusters_per_class : int, optional (default=2)
            The number of clusters per class.
        
        weights : list of floats or None (default=None)
            The proportions of samples assigned to each class. If None, then
            classes are balanced. Note that if `len(weights) == n_classes - 1`,
            then the last class weight is automatically inferred.
            More than `n_samples` samples may be returned if the sum of `weights`
            exceeds 1.
        
        flip_y : float, optional (default=0.01)
            The fraction of samples whose class are randomly exchanged. Larger
            values introduce noise in the labels and make the classification
            task harder.
        
        class_sep : float, optional (default=1.0)
            The factor multiplying the hypercube size.  Larger values spread
            out the clusters/classes and make the classification task easier.
        
        hypercube : boolean, optional (default=True)
            If True, the clusters are put on the vertices of a hypercube. If
            False, the clusters are put on the vertices of a random polytope.
        
        shift : float, array of shape [n_features] or None, optional (default=0.0)
            Shift features by the specified value. If None, then features
            are shifted by a random value drawn in [-class_sep, class_sep].
        
        scale : float, array of shape [n_features] or None, optional (default=1.0)
            Multiply features by the specified value. If None, then features
            are scaled by a random value drawn in [1, 100]. Note that scaling
            happens after shifting.
        
        shuffle : boolean, optional (default=True)
            Shuffle the samples and the features.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The generated samples.
        
        y : array of shape [n_samples]
            The integer labels for class membership of each sample.
        
        Notes
        -----
        The algorithm is adapted from Guyon [1] and was designed to generate
        the "Madelon" dataset.
        
        References
        ----------
        .. [1] I. Guyon, "Design of experiments for the NIPS 2003 variable
               selection benchmark", 2003.
        
        See also
        --------
        make_blobs: simplified variant
        make_multilabel_classification: unrelated generator for multilabel tasks
    
    make_friedman1(n_samples=100, n_features=10, noise=0.0, random_state=None)
        Generate the "Friedman \#1" regression problem
        
        This dataset is described in Friedman [1] and Breiman [2].
        
        Inputs `X` are independent features uniformly distributed on the interval
        [0, 1]. The output `y` is created according to the formula::
        
            y(X) = 10 * sin(pi * X[:, 0] * X[:, 1]) + 20 * (X[:, 2] - 0.5) ** 2 + 10 * X[:, 3] + 5 * X[:, 4] + noise * N(0, 1).
        
        Out of the `n_features` features, only 5 are actually used to compute
        `y`. The remaining features are independent of `y`.
        
        The number of features has to be >= 5.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        n_features : int, optional (default=10)
            The number of features. Should be at least 5.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise applied to the output.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The input samples.
        
        y : array of shape [n_samples]
            The output values.
        
        References
        ----------
        .. [1] J. Friedman, "Multivariate adaptive regression splines", The Annals
               of Statistics 19 (1), pages 1-67, 1991.
        
        .. [2] L. Breiman, "Bagging predictors", Machine Learning 24,
               pages 123-140, 1996.
    
    make_friedman2(n_samples=100, noise=0.0, random_state=None)
        Generate the "Friedman \#2" regression problem
        
        This dataset is described in Friedman [1] and Breiman [2].
        
        Inputs `X` are 4 independent features uniformly distributed on the
        intervals::
        
            0 <= X[:, 0] <= 100,
            40 * pi <= X[:, 1] <= 560 * pi,
            0 <= X[:, 2] <= 1,
            1 <= X[:, 3] <= 11.
        
        The output `y` is created according to the formula::
        
            y(X) = (X[:, 0] ** 2 + (X[:, 1] * X[:, 2]  - 1 / (X[:, 1] * X[:, 3])) ** 2) ** 0.5 + noise * N(0, 1).
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise applied to the output.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, 4]
            The input samples.
        
        y : array of shape [n_samples]
            The output values.
        
        References
        ----------
        .. [1] J. Friedman, "Multivariate adaptive regression splines", The Annals
               of Statistics 19 (1), pages 1-67, 1991.
        
        .. [2] L. Breiman, "Bagging predictors", Machine Learning 24,
               pages 123-140, 1996.
    
    make_friedman3(n_samples=100, noise=0.0, random_state=None)
        Generate the "Friedman \#3" regression problem
        
        This dataset is described in Friedman [1] and Breiman [2].
        
        Inputs `X` are 4 independent features uniformly distributed on the
        intervals::
        
            0 <= X[:, 0] <= 100,
            40 * pi <= X[:, 1] <= 560 * pi,
            0 <= X[:, 2] <= 1,
            1 <= X[:, 3] <= 11.
        
        The output `y` is created according to the formula::
        
            y(X) = arctan((X[:, 1] * X[:, 2] - 1 / (X[:, 1] * X[:, 3])) / X[:, 0]) + noise * N(0, 1).
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise applied to the output.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, 4]
            The input samples.
        
        y : array of shape [n_samples]
            The output values.
        
        References
        ----------
        .. [1] J. Friedman, "Multivariate adaptive regression splines", The Annals
               of Statistics 19 (1), pages 1-67, 1991.
        
        .. [2] L. Breiman, "Bagging predictors", Machine Learning 24,
               pages 123-140, 1996.
    
    make_gaussian_quantiles(mean=None, cov=1.0, n_samples=100, n_features=2, n_classes=3, shuffle=True, random_state=None)
        Generate isotropic Gaussian and label samples by quantile
        
        This classification dataset is constructed by taking a multi-dimensional
        standard normal distribution and defining classes separated by nested
        concentric multi-dimensional spheres such that roughly equal numbers of
        samples are in each class (quantiles of the :math:`\chi^2` distribution).
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        mean : array of shape [n_features], optional (default=None)
            The mean of the multi-dimensional normal distribution.
            If None then use the origin (0, 0, ...).
        
        cov : float, optional (default=1.)
            The covariance matrix will be this value times the unit matrix. This
            dataset only produces symmetric normal distributions.
        
        n_samples : int, optional (default=100)
            The total number of points equally divided among classes.
        
        n_features : int, optional (default=2)
            The number of features for each sample.
        
        n_classes : int, optional (default=3)
            The number of classes
        
        shuffle : boolean, optional (default=True)
            Shuffle the samples.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The generated samples.
        
        y : array of shape [n_samples]
            The integer labels for quantile membership of each sample.
        
        Notes
        -----
        The dataset is from Zhu et al [1].
        
        References
        ----------
        .. [1] J. Zhu, H. Zou, S. Rosset, T. Hastie, "Multi-class AdaBoost", 2009.
    
    make_hastie_10_2(n_samples=12000, random_state=None)
        Generates data for binary classification used in
        Hastie et al. 2009, Example 10.2.
        
        The ten features are standard independent Gaussian and
        the target ``y`` is defined by::
        
          y[i] = 1 if np.sum(X[i] ** 2) > 9.34 else -1
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=12000)
            The number of samples.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, 10]
            The input samples.
        
        y : array of shape [n_samples]
            The output values.
        
        References
        ----------
        .. [1] T. Hastie, R. Tibshirani and J. Friedman, "Elements of Statistical
               Learning Ed. 2", Springer, 2009.
        
        See also
        --------
        make_gaussian_quantiles: a generalization of this dataset approach
    
    make_low_rank_matrix(n_samples=100, n_features=100, effective_rank=10, tail_strength=0.5, random_state=None)
        Generate a mostly low rank matrix with bell-shaped singular values
        
        Most of the variance can be explained by a bell-shaped curve of width
        effective_rank: the low rank part of the singular values profile is::
        
            (1 - tail_strength) * exp(-1.0 * (i / effective_rank) ** 2)
        
        The remaining singular values' tail is fat, decreasing as::
        
            tail_strength * exp(-0.1 * i / effective_rank).
        
        The low rank part of the profile can be considered the structured
        signal part of the data while the tail can be considered the noisy
        part of the data that cannot be summarized by a low number of linear
        components (singular vectors).
        
        This kind of singular profiles is often seen in practice, for instance:
         - gray level pictures of faces
         - TF-IDF vectors of text documents crawled from the web
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        n_features : int, optional (default=100)
            The number of features.
        
        effective_rank : int, optional (default=10)
            The approximate number of singular vectors required to explain most of
            the data by linear combinations.
        
        tail_strength : float between 0.0 and 1.0, optional (default=0.5)
            The relative importance of the fat noisy tail of the singular values
            profile.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The matrix.
    
    make_moons(n_samples=100, shuffle=True, noise=None, random_state=None)
        Make two interleaving half circles
        
        A simple toy dataset to visualize clustering and classification
        algorithms. Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The total number of points generated.
        
        shuffle : bool, optional (default=True)
            Whether to shuffle the samples.
        
        noise : double or None (default=None)
            Standard deviation of Gaussian noise added to the data.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, 2]
            The generated samples.
        
        y : array of shape [n_samples]
            The integer labels (0 or 1) for class membership of each sample.
    
    make_multilabel_classification(n_samples=100, n_features=20, n_classes=5, n_labels=2, length=50, allow_unlabeled=True, sparse=False, return_indicator='dense', return_distributions=False, random_state=None)
        Generate a random multilabel classification problem.
        
        For each sample, the generative process is:
            - pick the number of labels: n ~ Poisson(n_labels)
            - n times, choose a class c: c ~ Multinomial(theta)
            - pick the document length: k ~ Poisson(length)
            - k times, choose a word: w ~ Multinomial(theta_c)
        
        In the above process, rejection sampling is used to make sure that
        n is never zero or more than `n_classes`, and that the document length
        is never zero. Likewise, we reject classes which have already been chosen.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        n_features : int, optional (default=20)
            The total number of features.
        
        n_classes : int, optional (default=5)
            The number of classes of the classification problem.
        
        n_labels : int, optional (default=2)
            The average number of labels per instance. More precisely, the number
            of labels per sample is drawn from a Poisson distribution with
            ``n_labels`` as its expected value, but samples are bounded (using
            rejection sampling) by ``n_classes``, and must be nonzero if
            ``allow_unlabeled`` is False.
        
        length : int, optional (default=50)
            The sum of the features (number of words if documents) is drawn from
            a Poisson distribution with this expected value.
        
        allow_unlabeled : bool, optional (default=True)
            If ``True``, some instances might not belong to any class.
        
        sparse : bool, optional (default=False)
            If ``True``, return a sparse feature matrix
        
            .. versionadded:: 0.17
               parameter to allow *sparse* output.
        
        return_indicator : 'dense' (default) | 'sparse' | False
            If ``dense`` return ``Y`` in the dense binary indicator format. If
            ``'sparse'`` return ``Y`` in the sparse binary indicator format.
            ``False`` returns a list of lists of labels.
        
        return_distributions : bool, optional (default=False)
            If ``True``, return the prior class probability and conditional
            probabilities of features given classes, from which the data was
            drawn.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The generated samples.
        
        Y : array or sparse CSR matrix of shape [n_samples, n_classes]
            The label sets.
        
        p_c : array, shape [n_classes]
            The probability of each class being drawn. Only returned if
            ``return_distributions=True``.
        
        p_w_c : array, shape [n_features, n_classes]
            The probability of each feature being drawn given each class.
            Only returned if ``return_distributions=True``.
    
    make_regression(n_samples=100, n_features=100, n_informative=10, n_targets=1, bias=0.0, effective_rank=None, tail_strength=0.5, noise=0.0, shuffle=True, coef=False, random_state=None)
        Generate a random regression problem.
        
        The input set can either be well conditioned (by default) or have a low
        rank-fat tail singular profile. See :func:`make_low_rank_matrix` for
        more details.
        
        The output is generated by applying a (potentially biased) random linear
        regression model with `n_informative` nonzero regressors to the previously
        generated input and some gaussian centered noise with some adjustable
        scale.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        n_features : int, optional (default=100)
            The number of features.
        
        n_informative : int, optional (default=10)
            The number of informative features, i.e., the number of features used
            to build the linear model used to generate the output.
        
        n_targets : int, optional (default=1)
            The number of regression targets, i.e., the dimension of the y output
            vector associated with a sample. By default, the output is a scalar.
        
        bias : float, optional (default=0.0)
            The bias term in the underlying linear model.
        
        effective_rank : int or None, optional (default=None)
            if not None:
                The approximate number of singular vectors required to explain most
                of the input data by linear combinations. Using this kind of
                singular spectrum in the input allows the generator to reproduce
                the correlations often observed in practice.
            if None:
                The input set is well conditioned, centered and gaussian with
                unit variance.
        
        tail_strength : float between 0.0 and 1.0, optional (default=0.5)
            The relative importance of the fat noisy tail of the singular values
            profile if `effective_rank` is not None.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise applied to the output.
        
        shuffle : boolean, optional (default=True)
            Shuffle the samples and the features.
        
        coef : boolean, optional (default=False)
            If True, the coefficients of the underlying linear model are returned.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The input samples.
        
        y : array of shape [n_samples] or [n_samples, n_targets]
            The output values.
        
        coef : array of shape [n_features] or [n_features, n_targets], optional
            The coefficient of the underlying linear model. It is returned only if
            coef is True.
    
    make_s_curve(n_samples=100, noise=0.0, random_state=None)
        Generate an S curve dataset.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of sample points on the S curve.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, 3]
            The points.
        
        t : array of shape [n_samples]
            The univariate position of the sample according to the main dimension
            of the points in the manifold.
    
    make_sparse_coded_signal(n_samples, n_components, n_features, n_nonzero_coefs, random_state=None)
        Generate a signal as a sparse combination of dictionary elements.
        
        Returns a matrix Y = DX, such as D is (n_features, n_components),
        X is (n_components, n_samples) and each column of X has exactly
        n_nonzero_coefs non-zero elements.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int
            number of samples to generate
        
        n_components :  int,
            number of components in the dictionary
        
        n_features : int
            number of features of the dataset to generate
        
        n_nonzero_coefs : int
            number of active (non-zero) coefficients in each sample
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        data : array of shape [n_features, n_samples]
            The encoded signal (Y).
        
        dictionary : array of shape [n_features, n_components]
            The dictionary with normalized components (D).
        
        code : array of shape [n_components, n_samples]
            The sparse code such that each column of this matrix has exactly
            n_nonzero_coefs non-zero items (X).
    
    make_sparse_spd_matrix(dim=1, alpha=0.95, norm_diag=False, smallest_coef=0.1, largest_coef=0.9, random_state=None)
        Generate a sparse symmetric definite positive matrix.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        dim : integer, optional (default=1)
            The size of the random matrix to generate.
        
        alpha : float between 0 and 1, optional (default=0.95)
            The probability that a coefficient is zero (see notes). Larger values
            enforce more sparsity.
        
        norm_diag : boolean, optional (default=False)
            Whether to normalize the output matrix to make the leading diagonal
            elements all 1
        
        smallest_coef : float between 0 and 1, optional (default=0.1)
            The value of the smallest coefficient.
        
        largest_coef : float between 0 and 1, optional (default=0.9)
            The value of the largest coefficient.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        prec : sparse matrix of shape (dim, dim)
            The generated matrix.
        
        Notes
        -----
        The sparsity is actually imposed on the cholesky factor of the matrix.
        Thus alpha does not translate directly into the filling fraction of
        the matrix itself.
        
        See also
        --------
        make_spd_matrix
    
    make_sparse_uncorrelated(n_samples=100, n_features=10, random_state=None)
        Generate a random regression problem with sparse uncorrelated design
        
        This dataset is described in Celeux et al [1]. as::
        
            X ~ N(0, 1)
            y(X) = X[:, 0] + 2 * X[:, 1] - 2 * X[:, 2] - 1.5 * X[:, 3]
        
        Only the first 4 features are informative. The remaining features are
        useless.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of samples.
        
        n_features : int, optional (default=10)
            The number of features.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, n_features]
            The input samples.
        
        y : array of shape [n_samples]
            The output values.
        
        References
        ----------
        .. [1] G. Celeux, M. El Anbari, J.-M. Marin, C. P. Robert,
               "Regularization in regression: comparing Bayesian and frequentist
               methods in a poorly informative situation", 2009.
    
    make_spd_matrix(n_dim, random_state=None)
        Generate a random symmetric, positive-definite matrix.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_dim : int
            The matrix dimension.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_dim, n_dim]
            The random symmetric, positive-definite matrix.
        
        See also
        --------
        make_sparse_spd_matrix
    
    make_swiss_roll(n_samples=100, noise=0.0, random_state=None)
        Generate a swiss roll dataset.
        
        Read more in the :ref:`User Guide <sample_generators>`.
        
        Parameters
        ----------
        n_samples : int, optional (default=100)
            The number of sample points on the S curve.
        
        noise : float, optional (default=0.0)
            The standard deviation of the gaussian noise.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        Returns
        -------
        X : array of shape [n_samples, 3]
            The points.
        
        t : array of shape [n_samples]
            The univariate position of the sample according to the main dimension
            of the points in the manifold.
        
        Notes
        -----
        The algorithm is from Marsland [1].
        
        References
        ----------
        .. [1] S. Marsland, "Machine Learning: An Algorithmic Perspective",
               Chapter 10, 2009.
               http://seat.massey.ac.nz/personal/s.r.marsland/Code/10/lle.py
    
    sample_without_replacement(...)
        Sample integers without replacement.
        
        Select n_samples integers from the set [0, n_population) without
        replacement.
        
        
        Parameters
        ----------
        n_population : int,
            The size of the set to sample from.
        
        n_samples : int,
            The number of integer to sample.
        
        random_state : int, RandomState instance or None, optional (default=None)
            If int, random_state is the seed used by the random number generator;
            If RandomState instance, random_state is the random number generator;
            If None, the random number generator is the RandomState instance used
            by `np.random`.
        
        method : "auto", "tracking_selection", "reservoir_sampling" or "pool"
            If method == "auto", the ratio of n_samples / n_population is used
            to determine which algorithm to use:
            If ratio is between 0 and 0.01, tracking selection is used.
            If ratio is between 0.01 and 0.99, numpy.random.permutation is used.
            If ratio is greater than 0.99, reservoir sampling is used.
            The order of the selected integers is undefined. If a random order is
            desired, the selected subset should be shuffled.
        
            If method =="tracking_selection", a set based implementation is used
            which is suitable for `n_samples` <<< `n_population`.
        
            If method == "reservoir_sampling", a reservoir sampling algorithm is
            used which is suitable for high memory constraint or when
            O(`n_samples`) ~ O(`n_population`).
            The order of the selected integers is undefined. If a random order is
            desired, the selected subset should be shuffled.
        
            If method == "pool", a pool based algorithm is particularly fast, even
            faster than the tracking selection method. Hovewer, a vector containing
            the entire population has to be initialized.
            If n_samples ~ n_population, the reservoir sampling method is faster.
        
        Returns
        -------
        out : array of size (n_samples, )
            The sampled subsets of integer. The subset of selected integer might
            not be randomized, see the method argument.

FILE
    c:\python\python36-32\lib\site-packages\sklearn\datasets\samples_generator.py


>>> help('matplotlib.pyplot.fill_between')
Help on function fill_between in matplotlib.pyplot:

matplotlib.pyplot.fill_between = fill_between(x, y1, y2=0, where=None, interpolate=False, step=None, hold=None, data=None, **kwargs)
    Fill the area between two horizontal curves.
    
    The curves are defined by the points (*x*, *y1*) and (*x*, *y2*). This
    creates one or multiple polygons describing the filled area.
    
    You may exclude some horizontal sections from filling using *where*.
    
    By default, the edges connect the given points directly. Use *step* if
    the filling should be a step function, i.e. constant in between *x*.
    
    
    Parameters
    ----------
    x : array (length N)
        The x coordinates of the nodes defining the curves.
    
    y1 : array (length N) or scalar
        The y coordinates of the nodes defining the first curve.
    
    y2 : array (length N) or scalar, optional, default: 0
        The y coordinates of the nodes defining the second curve.
    
    where : array of bool (length N), optional, default: None
        Define *where* to exclude some horizontal regions from being
        filled. The filled regions are defined by the coordinates
        ``x[where]``.  More precisely, fill between ``x[i]`` and ``x[i+1]``
        if ``where[i] and where[i+1]``.  Note that this definition implies
        that an isolated *True* value between two *False* values in
        *where* will not result in filling.  Both sides of the *True*
        position remain unfilled due to the adjacent *False* values.
    
    interpolate : bool, optional
        This option is only relvant if *where* is used and the two curves
        are crossing each other.
    
        Semantically, *where* is often used for *y1* > *y2* or similar.
        By default, the nodes of the polygon defining the filled region
        will only be placed at the positions in the *x* array.  Such a
        polygon cannot describe the above semantics close to the
        intersection.  The x-sections containing the intersecion are
        simply clipped.
    
        Setting *interpolate* to *True* will calculate the actual
        interscection point and extend the filled region up to this point.
    
    step : {'pre', 'post', 'mid'}, optional
        Define *step* if the filling should be a step function,
        i.e. constant in between *x*. The value determines where the
        step will occur:
    
        - 'pre': The y value is continued constantly to the left from
          every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
          value ``y[i]``.
        - 'post': The y value is continued constantly to the right from
          every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
          value ``y[i]``.
        - 'mid': Steps occur half-way between the *x* positions.
    
    Other Parameters
    ----------------
    **kwargs
        All other keyword arguments are passed on to `.PolyCollection`.
        They control the `.Polygon` properties:
    
          agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array 
      alpha: float or None 
      animated: bool 
      antialiased or antialiaseds: Boolean or sequence of booleans 
      array: ndarray
      capstyle: unknown
      clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs. 
      clip_box: a `.Bbox` instance 
      clip_on: bool 
      clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None] 
      cmap: a colormap or registered colormap name 
      color: matplotlib color arg or sequence of rgba tuples
      contains: a callable function 
      edgecolor or edgecolors: matplotlib color spec or sequence of specs 
      facecolor or facecolors: matplotlib color spec or sequence of specs 
      figure: a `.Figure` instance 
      gid: an id string 
      hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ] 
      joinstyle: unknown
      label: object 
      linestyle or dashes or linestyles: ['solid' | 'dashed', 'dashdot', 'dotted' | (offset, on-off-dash-seq) | ``'-'`` | ``'--'`` | ``'-.'`` | ``':'`` | ``'None'`` | ``' '`` | ``''``]
      linewidth or linewidths or lw: float or sequence of floats 
      norm: `.Normalize`
      offset_position: [ 'screen' | 'data' ] 
      offsets: float or sequence of floats 
      path_effects: `.AbstractPathEffect` 
      picker: [None | bool | float | callable] 
      pickradius: float distance in points
      rasterized: bool or None 
      sketch_params: (scale: float, length: float, randomness: float) 
      snap: bool or None 
      transform: `.Transform` 
      url: a url string 
      urls: List[str] or None 
      visible: bool 
      zorder: float 
    
    Returns
    -------
    `.PolyCollection`
        A `.PolyCollection` containing the plotted polygons.
    
    See Also
    --------
    fill_betweenx : Fill between two sets of x-values.
    
    Notes
    -----
    .. [notes section required to get data note injection right]
    
    .. note::
        In addition to the above described arguments, this function can take a
        **data** keyword argument. If such a **data** argument is given, the
        following arguments are replaced by **data[<arg>]**:
    
        * All arguments with the following names: 'where', 'x', 'y1', 'y2'.

>>> help('matplotlib.pyplot.plt.xlim(-1,3.5)')
No Python documentation found for 'matplotlib.pyplot.plt.xlim(-1,3.5)'.
Use help() to get the interactive help utility.
Use help(str) for help on the str class.

>>> help('matplotlib.pyplot.plt.xlim()')
No Python documentation found for 'matplotlib.pyplot.plt.xlim()'.
Use help() to get the interactive help utility.
Use help(str) for help on the str class.

>>> help('matplotlib.pyplot.xlim()')
No Python documentation found for 'matplotlib.pyplot.xlim()'.
Use help() to get the interactive help utility.
Use help(str) for help on the str class.

>>> help('plt.xlim()')
No Python documentation found for 'plt.xlim()'.
Use help() to get the interactive help utility.
Use help(str) for help on the str class.

>>> help('matplotlib.pyplot.xlim')
Help on function xlim in matplotlib.pyplot:

matplotlib.pyplot.xlim = xlim(*args, **kwargs)
    Get or set the x limits of the current axes.
    
    Call signatures::
    
        xmin, xmax = xlim()  # return the current xlim
        xlim((xmin, xmax))   # set the xlim to xmin, xmax
        xlim(xmin, xmax)     # set the xlim to xmin, xmax
    
    If you do not specify args, you can pass *xmin* or *xmax* as kwargs, i.e.::
    
        xlim(xmax=3)  # adjust the max leaving min unchanged
        xlim(xmin=1)  # adjust the min leaving max unchanged
    
    Setting limits turns autoscaling off for the x-axis.
    
    Returns
    -------
    xmin, xmax
        A tuple of the new x-axis limits.
    
    Notes
    -----
    Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
    equivalent of calling `~.Axes.get_xlim` on the current axes.
    Calling this function with arguments is the pyplot equivalent of calling
    `~.Axes.set_xlim` on the current axes. All arguments are passed though.

>>> 
